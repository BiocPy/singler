from typing import Sequence, Union
from numpy import array, ndarray, int32, float64, uintp
from mattress import tatamize
from biocframe import BiocFrame

from .build_integrated_references import IntegratedReferences
from . import _cpphelpers as lib
from ._utils import _match


def classify_integrated_references(
    test_data,
    results: list[Union[BiocFrame, Sequence]],
    integrated_prebuilt: IntegratedReferences,
    quantile=0.8,
    num_threads=1,
) -> BiocFrame:
    """Integrate classification results across multiple references for a single test dataset.

    Args:
        test_data: A matrix-like object where each row is a feature and each column
            is a test sample (usually a single cell), containing expression values.
            Normalized and/or transformed expression values are also acceptable as only
            the ranking is used within this function.

        results (list[Union[BiocFrame, Sequence]]):
            List of classification results generated by running
            :py:meth:`~singler.classify_single_reference.classify_single_reference`
            on ``test_data`` with each reference. This may be either the full
            data frame or just the ``"best"`` column. References should be ordered
            as in ``integrated_prebuilt.reference_names``.

        integrated_prebuilt (IntegratedReferences):
            Integrated reference object, constructed with
            :py:meth:`~singler.build_integrated_references.build_integrated_references`.

        quantile (float):
            Quantile of the correlation distribution for computing the score for each label.
            Larger values increase sensitivity of matches at the expense of
            similarity to the average behavior of each label.

        num_threads (int):
            Number of threads to use during classification.

    Returns:
        BiocFrame: A data frame containing the ``best_label`` label across references,
        the ``best_reference`` from which it came, the ``scores`` for each reference
        (as a nested BiocFrame), and the ``delta`` from the best to the second-best
        reference. Each row corresponds to a column of ``test``.
    """

    test_ptr = tatamize(test_data)
    if test_ptr.nrow() != len(integrated_prebuilt.test_features):
        raise ValueError(
            "number of rows in 'test_data' should equal number of features in 'integrated_prebuilt'"
        )
    nc = test_ptr.ncol()
    best = ndarray((nc,), dtype=int32)
    delta = ndarray((nc,), dtype=float64)

    all_refs = integrated_prebuilt.reference_names
    all_labels = integrated_prebuilt.reference_labels
    nref = len(all_refs)

    scores = {}
    score_ptrs = ndarray((nref,), dtype=uintp)
    assign_ptrs = ndarray((nref,), dtype=uintp)

    if len(all_refs) != len(results):
        raise ValueError(
            "length of 'results' should equal number of references in 'integrated_prebuilt'"
        )

    for i, r in enumerate(all_refs):
        current = ndarray((nc,), dtype=float64)
        scores[r] = current
        score_ptrs[i] = current.ctypes.data

        curlabs = results[i]
        if isinstance(curlabs, BiocFrame):
            curlabs = curlabs.column("best")
        if len(curlabs) != nc:
            raise ValueError(
                "each entry of 'results' should have results for all cells in 'test_data'"
            )

        ind = array(_match(curlabs, all_labels[i]), dtype=int32)
        all_labels.append(ind)
        assign_ptrs[i] = ind.ctypes.data

    lib.classify_integrated_references(
        test_ptr.ptr,
        assign_ptrs.ctypes.data,
        integrated_prebuilt._ptr,
        quantile,
        score_ptrs.ctypes.data,
        best,
        delta,
        num_threads,
    )

    scores_df = BiocFrame(scores, number_of_rows=nc)
    return BiocFrame(
        {
            "best_label": [results[b][i] for i, b in enumerate(best)],
            "best_reference": [all_refs[b] for b in best],
            "scores": scores_df,
            "delta": delta,
        }
    )
